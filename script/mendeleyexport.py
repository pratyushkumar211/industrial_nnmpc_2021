#!/usr/bin/env python3

# Full help generated by argparse.
"""
Used to take the output of a Mendeley export and reformat the .bib file to fix a
few issues. Primarily, the script gets rid of some weird fields that Mendeley
includes.

By default, the following fields are retained:
    
    author institution journal pages title number volume year booktitle
    address series editor publisher howpublished

If you would like to retain additional fields, you can use the --keep argument.
To exclude any of these fields, use --exclude (or --nodefaults to not use any
defaults). For both --keep and --exclude, you can pass a combination of
multiple arguments, or a single argument with commas between fields. E.g.,

    --keep url --keep abstract --exclude booktitle --exclude address

and

    --keep url,abstract --exclude booktitle,address

have the same effect. Note that all --keep arguments are applied after all
--exclude arguments.

The other things that happen are the replacement of journal names with the
corresponding key from the Rawlings Group bib repo. This is done by looking for
a /jkey=*/ tag from Mendeley (thus, these keys need to be specified within
Mendeley). Also, the script preserves capitalization using | as a delimiter.
E.g., if the Mendeley title is "Review of |MPC|", then the .bib file will have
a title of "review of {MPC}" so that capitalization of MPC is enforced in the
bibliography.

Finally, if the optional argument KEYFILE is provided, then the script will
generate systematic author1:author2: ... :authorN:year bibliography keys and
create a file that maps existing keys to these systematic names. In theory,
this will only be necessary if someone else gives you their bibliography and you
want to change all the keys to systematic names.
"""

import argparse
import itertools
import re
import os
import sys

# Argparse stuff for command line arguments.
def getfilecheck(ext=None, exists=True, toAbs=False):
    """
    Returns a funcion to check whether inputs are valid files/directories.
    """
    def filecheck(s):
        s = str(s)
        if toAbs:
            try:
                s = os.path.abspath(s)
            except: # Catch everything here.
                raise argparse.ArgumentTypeError("unable to get absolute path")
        if ext is not None and not s.endswith(ext):
            raise argparse.ArgumentTypeError("must have '%s' extension" % ext)
        if exists:
            if not os.path.isfile(s):
                raise argparse.ArgumentTypeError("must be an existing file")
        return s
    return filecheck

# Build the parser in the global namespace so everybody has access.
parser = argparse.ArgumentParser(add_help=False, description=
        "Cleans up a .bib file from Mendeley to fix capitalization, etc.",
        epilog=__doc__, formatter_class=argparse.RawDescriptionHelpFormatter)
parser.add_argument("--help", help="print this help and exit.", action="help")
parser.add_argument("--out", help="output file for cleaned bib.",
                    type=getfilecheck(".bib", exists=False))
parser.add_argument("--keyfile", help="make cite keys systematically and "
                    "dump map to file", type=getfilecheck(exists=False))
parser.add_argument("--excludefile", help="exclude keys listed in a file.",
                    type=getfilecheck(".exclude"))
parser.add_argument("--url-as-note", help="move any URLs to the note field.",
                    action="store_true")
parser.add_argument("--debug", help="enable debugging messages",
                    action="store_true")
parser.add_argument("--keep", help="extra fields to keep.", action="append",
                    default=[])
parser.add_argument("--exclude", help="fields to specifically exclude.",
                    action="append", default=[])
parser.add_argument("--nodefaults", help="don't keep any fields by default",
                    action="store_true")
parser.add_argument("file", help="Mendeley bibliography file.",
                    type=getfilecheck(".mendeleybib"))

# Define a global DEBUG flag.
DEBUG = False

class BibEntry(object):
    """Structure to hold information about a bibliography entry."""
    def __init__(self, rawkey=None, etype=None):
        """Initialize the object."""
        self.lines = {}
        self.lastnames = []
        self.year = None
        self.rawkey = rawkey
        self.key = None
        self.rawauthor = None
        self.etype = etype
        self.done = False
        self.forcefields = set()
        self.orgauthor = False
        self.jkey = None

# Now make all the helper functions.
def cleanupbibfile(infilename, outfilename, keyfilename, keepfields,
                   usejournalkeys=True, excludekeys=set(), changetypes=True,
                   allowforcefields=True, urlasnote=False):
    """
    Takes bib file from Mendeley and cleans up a bunch of issues.
    
    infilename is the name of the input mendeley file. outfile is the file in
    which the clean bib is outputted.
    
    keyfilename is the file in which the key mapping is outputted. If it is a
    nonempty string, systematic citation keys will be made of the form
    
        author1:author2:...:authorN:year
    
    and the mapping between the old citation keys and the new systematic keys
    will be given in keyfilename.
    
    keepfields is a set of field names to print in the cleaned entry. Any
    fields not in this list will be ignored. However, if an entry has a tag of
    the form /force=*/, then that field will always be printed. This behavior
    can be disabled by setting allowforcefields=False. The typical use case is
    to ignore URLs by default but force them for some entries that are only
    available online.
    
    usejournalkeys is a boolean flag whether to look for /jkey=*/ tags which
    will then be used in place of the given journal name. This is useful, e.g.,
    to make use of the group's fullnames.bib vs. abbreviations.bib.
    
    excludekeys is a list of keys to ignore. If any of these keys are found in
    infile, then they are not printed.
    
    changetypes allows the entry type to be changed using /type=*/ tags.
    """
    if excludekeys is None:
        excludekeys = set()
    infile = open(infilename,"r")
    outfile = open(outfilename,"w")
    
    if keyfilename is not None and len(keyfilename) > 0:
        newKeySet = set()
        newKeyDict = dict()
        makeNewKeys = True
    else:
        makeNewKeys = False
    
    checknewentry = re.compile(r"^(?P<type>@[\w\-]*\{)(?P<key>.*?),$")
    getfieldandtext = re.compile(r"^(?P<field>[\w\-]*?) *= "
                                 r"*\{(?P<text>.*?)\},?$")
    
    getjkey = re.compile(r"/jkey=(?P<jkey>[\w0-9]*)/")
    getforcefields = re.compile(r"/force=(?P<forcefields>[\w0-9,]*)/")
    gettype = re.compile(r"/type=(?P<type>\w*)/")
    checkorgauthor = re.compile(r"/orgauthor/")
    getnote = re.compile(r"/note=(?P<note>.*)/")
      
    keepgoing = True
    entry = BibEntry()
    nextentry = None
    linectr = 0
    while keepgoing:
        rawline = infile.readline()
        if len(rawline) == 0: # At end of file.
            entry.done = True
            keepgoing = False
        else: # Figure out what line is.
            linectr += 1
            newentry = checknewentry.match(rawline)
            if newentry: # Beginning of new entry.
                if DEBUG:
                    print("New entry found at line %d." % linectr)
                nextentry = BibEntry(newentry.group("key"),
                                     newentry.group("type"))
                entry.done = True
            else:
                fieldentry = getfieldandtext.match(rawline)
                if fieldentry is not None:
                    field = fieldentry.group("field").lower()
                    text = bibclean(fieldentry.group("text"))
                    
                    if DEBUG:
                        print("Field '%s' found at line %d: "
                              % (field, linectr))
                    
                    if field == "keywords": # Check for some special tags.
                        if usejournalkeys: # Check journal key.
                            jkeymatch = getjkey.search(text)
                            if jkeymatch is not None:
                                entry.jkey = jkeymatch.group("jkey")
                        if allowforcefields:
                            ffmatch = getforcefields.search(text)
                            if ffmatch:
                                ffs = ffmatch.group("forcefields").split(",")
                                entry.forcefields.update(ffs)
                        if checkorgauthor.search(text):
                            entry.orgauthor = True
                        if changetypes:
                            typesearch = gettype.search(text)
                            if typesearch is not None:
                                entrytype = typesearch.group("type")
                                if DEBUG:
                                    print("***Entry type change to '%s'"
                                          % entrytype)
                                
                                # Need to add @ and { to match normal entries.
                                entry.etype = "@" + entrytype + "{"
                        # Check for note.
                        notematch = getnote.search(text)
                        if notematch is not None:
                            entry.lines["note"] = notematch.group("note")
                    
                    # Store line to dictionary.
                    entry.lines[field] = text
                    
                    if field == "author":
                        entry.rawauthor = text
                        individualnames = entry.rawauthor.split(" and ")
                        entry.lastnames = [] # Save list of lastnames.
                        for name in individualnames:
                            firstandlast = name.split(", ")
                            lname = firstandlast[0].lower()
                                # Make lower case.
                            lname = re.sub(r"\\.", "", lname)
                                # Strip escaped characters.
                            lname = lname.replace("{", "")
                            lname = lname.replace("}", "") # Strip braces.
                            lname = lname.replace(" ", "") # Strip spaces.
                            entry.lastnames.append(lname)
                    elif field == "year":
                        entry.year = text # Save year.                           
        if entry.done:
            if len(entry.lines) > 0: # Something to output.
                # First, get rid of fields we don't want.
                thiskeepfields = keepfields.union(entry.forcefields)
                popfields = set(entry.lines.keys()).difference(thiskeepfields)
                for f in popfields:
                    entry.lines.pop(f)
                
                # Then, check if author is an organization and modify
                # accordingly to preserve spaces.
                if entry.orgauthor and "author" in entry.lines:
                    author = entry.rawauthor.replace(" ", r"{\ }")
                    entry.lines["author"] = "{%s}" % author
                
                if urlasnote and "url" in entry.lines:
                    note = entry.lines.get("note", "")
                    if len(note) > 0:
                        note += " "
                    note += "URL: {}".format(entry.lines["url"])
                    entry.lines["note"] = note
                
                # Now handle whether we make new bibliography keys.
                if makeNewKeys:
                    goodkey = ":".join(entry.lastnames + [entry.year])
                    
                    # Need to avoid duplicate keys.
                    ctr = 0
                    while goodkey + inttoalpha(ctr) in newKeySet:
                        ctr += 1
                    goodkey += inttoalpha(ctr)
                    newKeySet.add(goodkey)
                    newKeyDict[entry.rawkey] = goodkey # Store to dictionary.
                    entry.key = goodkey
                else:
                    entry.key = entry.rawkey # Just use whatever is there.
                if entry.key not in excludekeys:
                    outputcleanedentry(entry, outfile) # Output bib entry.
            
            # Move on to next entry.
            entry = nextentry
            
    if makeNewKeys:
        # Output old and new keys.
        keyfile = open(keyfilename,"w")
        for k in sorted(newKeyDict.keys()):
            keyfile.write(k + "\t" + newKeyDict[k] + "\n")
        keyfile.close()
    
    infile.close()
    outfile.close()
                                    
def outputcleanedentry(entry, outfile):
    """Prints a cleaned bib entry."""
    outfile.write(entry.etype)
    outfile.write(entry.key + ",\n")
    for (linekey, line) in entry.lines.items():
        if linekey == "journal" and len(entry.jkey or "") > 0:
            outfile.write(" journal = %s,\n" % entry.jkey)
        else:
            outfile.write(' {} = "{}",\n'.format(linekey, line))
    outfile.write("}\n")
    
def bibclean(strin):
    """Cleans a number of things for output into the cleaned bib file."""
    while True: # Remove brace pairs on outside.
        m = re.match("^\{(.*)\}$",strin)
        if m:
            strin = m.group(1)  
        else:
            break
    strin = re.sub(r"\\(.)\{(.)\}",r"{\\\1 \2}",strin)
        # Change \"{a} to {\" a} to make Bibtex happy.
    strin = re.sub("\|(.*?)\|",r"{\1}",strin)
        # Change |x| to {x} to enforce caps.
    return strin

def inttoalpha(num):
    """Converts a decimal integer to its base 26 a through z representation."""
    retval = ""
    while num > 0:
        c = (num - 1) % 26
        retval = chr(ord("a") + c) + retval
        num = (num - c)/26
    return retval

def chainsplit(iterable, splitchar=","):
    """Returns a chain object that splits each of the strings in iterable."""
    pieces = (i.split(splitchar) for i in iterable)
    return itertools.chain.from_iterable(pieces)

def main():
    """Main function that checks arguments and calls helpers."""
    global DEBUG
    # Fields are hard-coded. I suppose we could read them from a file, but
    # that sort of seems like overkill.
    keepfields = set(("author","institution","journal","pages","title",
                      "number","volume","year","booktitle","address",
                      "series","editor","publisher","howpublished"))
    
    # Read command line arguments.
    options = vars(parser.parse_args(sys.argv[1:]))
    DEBUG = options["debug"]    
    keyfilename = options["keyfile"]
    outfilename = options["out"]
    excludefilename = options["excludefile"]    
    bibfilename = options["file"]    
    
    # Choose which fields to keep and which to exclude.
    if options["nodefaults"]:
        keepfields = set()
    for f in chainsplit(options["exclude"]):
        keepfields.discard(f)
    for f in chainsplit(options["keep"]):
        keepfields.add(f)
    
    # Sort out defaults.
    if outfilename is None:
        outfilename = re.sub(".mendeleybib$", ".bib", bibfilename)   
    
    # Check for exclude file. Otherwise, search for %EXCLUDE% comments.
    excludekeys = set()    
    if excludefilename is not None:
        with open(excludefilename, "r") as excludefile:
            for line in excludefile:
                line = line.strip()
                if not line.startswith("#"):
                    excludekeys.add(line)
    else:
        excludemarker = "%EXCLUDE%"
        with open(bibfilename, "r") as bib:
            for line in bib:
                if line.startswith(excludemarker):
                    keys = line[len(excludemarker):].split()
                    excludekeys.update(keys)
    
    # Now do the actual work.
    cleanupbibfile(bibfilename, outfilename, keyfilename, keepfields,
                   excludekeys=excludekeys, urlasnote=options["url_as_note"])
    print("**File <%s> created from input <%s>." % (outfilename, bibfilename))
    sys.exit(0)

# Run main function if invoked as script.
if __name__ == "__main__":    
    main()
