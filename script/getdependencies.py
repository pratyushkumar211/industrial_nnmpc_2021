#!/usr/bin/env python3

# Help message is automatically generated by argparse module. Invoke from a
# terminal to see all available options.
"""
Scans the header of file <file> to look for a make rule and inserts them into
the file <file>.dep. The "header" is all lines at the top of the file that
either begin with % or # (possibly with whitespace in front) or are empty.
Once a non-header line is encountered, the script stops searching; this is done
for speed.

For details on how the dependencies should be specified, see .README.md inside
the .dependencies directory.

Note that the special figure targets refer to or figures that have
different versions for the paper, presentation, and poster (e.g. matplotlib).
These folders are hard-coded, so you will need to edit this source if you want
to put them in different places.
"""

import argparse
import collections
import io
import itertools
import os
import re
import subprocess
import sys
import traceback


# Define what directories to prepend for various %DIR% specifications. The
# first dictionary is for subdirectories of the build directory, the second
# is not subdirectories of the build directory.
SPECIALDIRS = {"FIGURE": ["build/figures/{}/".format(d) for d in
                          ["grey", "paper", "poster", "presentation"]],
               "SCRIPT": ["script/"], "LIB" : ["lib/"], "SRC" : [""]}
SPECIALS = {"THISFIGURE" : "%FIGURE%/{}.pdf", "THISMAT" : "{}.mat",
            "THISTEX" : "{}.tex", "THISGNUPLOT" : "{}.gnuplot",
            "THISDAT" : "{}.dat", "THISPDF" : "{}.pdf",
            "THISPICKLE" : "{}.pickle"}

# Define set for new-style [makes]; "[makes] *" gets mapped to "%THIS*%". 
MAKES_SPECIALS = {"figure", "gnuplot", "mat", "dat", "tex", "pdf", "pickle"}

# Set default [makes] based on file extensions.
DEFAULT_MAKES = {".py": "figure", ".m": "mat", ".jl": "mat",
                 ".tex": "pdf", ".gp": "gnuplot"}


def parseargs(args, epilog=__doc__):
    """Parses command-line arguments for main function."""
    description = "automatically look for dependencies in a given file"
    formatter = argparse.RawDescriptionHelpFormatter
    parser = argparse.ArgumentParser(add_help=False, description=description,
                                     epilog=epilog, formatter_class=formatter)
    parser.add_argument("--help", help="print this help", action="help")
    parser.add_argument("--build", help="directory prepended to targets",
                        default="")
    parser.add_argument("--output", help="write to file instead of stdout")
    parser.add_argument("file", help="source file")
    kwargs = vars(parser.parse_args(args))
    return kwargs


def getheader(file):
    """
    Returns the header lines of a file as a list.
    
    Comment characters and leading whitespace are removed.
    """
    (_, ext) = os.path.splitext(file)
    comment = {".m" : "%", ".tex" : "%"}.get(ext, "#")
    header = []
    with open(file, "r") as file:
        for line in file:
            line = line.lstrip()
            if len(line) > 0:
                if line.startswith(comment):
                    while line.startswith(comment):
                        line = line[len(comment):].lstrip()
                else:
                    break
            header.append(line)
    return header


class SourceFile:
    """Class for holding dependency information from a source file."""
    def __init__(self, name, builddir="build"):
        """Initializes the object."""
        self.name = name
        (self.base, self.ext) = os.path.splitext(name)
        self.builddir = builddir
        self.__errors = []
        self.__rules = []
        try:
            self.header = getheader(name)
        except FileNotFoundError:
            self.error("Root file {!r} not found!", name)
            self.header = []
    
    
    def error(self, msg, *args, **kwargs):
        """Adds an error to the current list of errors (format-style)."""
        self.__errors.append(msg.format(*args, **kwargs))
    
    
    def rule(self, targets, dependencies):
        """Adds the given targets : dependencies rule."""
        if len(targets) > 0 and len(dependencies) > 0:
            self.__rules.append("{} : {}".format(" ".join(targets),
                                                 " ".join(dependencies)))
    
    
    def getdeps(self):
        """Get dependencies from the file."""
        self.getnewstyledeps()
        self.getoldstyledeps()
        if self.name.endswith(".tex"):
            self.getbibliographydeps()
    
    
    def getoldstyledeps(self, prefix="<<MAKERULE>>"):
        """Get old-style dependencies and append them to the header."""
        def formatnames(namestr):
            """Formats multiple filenames in a whitespace-delimited list."""
            cleannames = (self.formatfilename(f)
                          for f in namestr.split())
            return list(itertools.chain.from_iterable(cleannames))
        for (i, line) in enumerate(self.header):
            if line.startswith(prefix):
                try:
                    (targets, dependencies) = line[len(prefix):].split(":")
                except ValueError:
                    self.error("Invalid {} on line {:d} of {!r}", prefix,
                               i + 1, self.name)
                else:
                    targets = formatnames(targets)
                    dependencies = formatnames(dependencies)
                    self.rule(targets, dependencies)
    
    
    def getnewstyledeps(self, recursive=True):
        """Gets new-style dependencies from the header."""
        # Search root header for [makes].
        MAKES = "[makes]"
        makes = DEFAULT_MAKES.get(self.ext, None)
        makeslines = []
        for (i, line) in enumerate(self.header):
            if line.startswith(MAKES):
                makeslines.append(i)
                thismakes = line[len(MAKES):].strip()
                if thismakes not in MAKES_SPECIALS:
                    self.error("Unknown {} in {!r}: {!r}", MAKES, self.name,
                               thismakes)
                else:
                    makes = thismakes
        if len(makeslines) > 1:
            self.error("File {!r} specifies multiple {} on lines {}",
                       self.name, MAKES, ", ".join(self.makeslines))
        if makes is not None:
            targets = self.formatfilename("%THIS{}%".format(makes.upper()))
        else:
            targets = None
        
        # Search headers for [depends], possibly recursively.
        DEPENDS = "[depends]"
        recursiveexts = {".m", ".py", ".jl", ".gp"} if recursive else set()
        tosearch = {self}
        searched = set()
        notfound = []
        dependedby = collections.defaultdict(set)
        while len(tosearch) > 0:
            # Get file and header.
            file = tosearch.pop()
            if file is self:
                file = self.name
                filedir = self.builddir
                header = self.header
            else:
                filedir = os.path.dirname(file)
                try:
                    header = getheader(file)
                except FileNotFoundError:
                    notfound.append(file)
                    header = []
            searched.add(file)
            
            # Search current header.
            thisdeps = set()
            for line in header:
                if line.startswith(DEPENDS):
                    linedeps = line[len(DEPENDS):].split()
                    for dep in linedeps:
                        cleandep = self.formatfilename(dep, indir=filedir,
                                                       fromfile=file)
                        thisdeps.update(cleandep)
            
            # Add current dependencies and look for new files.
            for dep in thisdeps:
                dependedby[dep].add(file)
                if dep not in searched:
                    (_, ext) = os.path.splitext(dep)
                    if ext in recursiveexts:
                        tosearch.add(dep)
                    else:
                        searched.add(dep)
        dependencies = dependedby.keys()
                        
        # Print error messages for missing files.
        for file in notfound:
            self.error("File {!r} not found ({} by {})", file, DEPENDS,
                       ", ".join(repr(f) for f in dependedby[file]))
        
        # Add rule.
        self.rule(targets, dependencies)

        
    def formatfilename(self, filename, indir=None, fromfile=None):
        """Formats the given filename, substituting any specials."""
        if fromfile is None:
            fromfile = self.name
        if indir is None:
            indir = self.builddir
        
        # Regex for specials.
        specials = re.search(r"^%(\w*)%$", filename)
        if specials is not None:
            special = specials.group(1)
            if special in SPECIALS:
                filename = SPECIALS[special].format(self.base)
            else:
                self.error("Invalid special {!r} in {!r}", special, fromfile)
    
        # Regex for special dirs.
        specialdirre = re.compile(r"%(\w*)%/")
        specialdirs = specialdirre.search(filename)
        dirs = [indir]
        if specialdirs is not None:
            specialdir = specialdirs.group(1)
            if specialdir in SPECIALDIRS:
                dirs = SPECIALDIRS[specialdir]
                filename = specialdirre.sub("", filename) # Remove wildcards.
            else:
                self.error("Invalid special dir {!r} in {!r}", specialdir,
                           self.name if fromfile is None else fromfile)
    
        # Prepend directories and return.
        return [os.path.join(d, filename) for d in dirs]
    
    
    def getbibliographydeps(self):
        """Gets bibliography dependencies from a .tex file."""
        bibdata = []
        bibliography = re.compile(r"\\(?:bibliography|addbibresource)"
                                  r"\{(?P<bibdata>[^}]*)\}")
        with open(self.name, "r") as texfile:
            for line in texfile:
                m = bibliography.search(line)
                if m is not None:
                    bibdata.append(m.group("bibdata"))
        self.rule([os.path.join(self.builddir, self.base + ".pdf")],
                   kpsewhich(bibdata, cwd=self.builddir))
        

    def writedeps(self, out):
        """Writes dependencies to output file."""
        for rule in self.__rules:
            out.write(rule + "\n\n")
        for error in self.__errors:
            out.write("$(warning {})\n\n".format(error))


def kpsewhich(bibdatas, cwd="."):
    """
    Runs kpsewhich on a list of entries and returns full paths for each.
    """
    bibfiles = []
    for bibdata in bibdatas:
        for bib in bibdata.split(","):
            bib = bib.strip()
            if not bib.endswith(".bib"):
                bib += ".bib"
            bibfiles.append(bib)
    bibfull = []
    if len(bibfiles) > 0:
        kpse = subprocess.Popen(["kpsewhich"] + bibfiles, cwd=cwd,
                                stdout=subprocess.PIPE)
        (bibfullraw, _) = kpse.communicate()
        
        for bfile in bibfullraw.decode().split("\n"):
            if len(bfile) > 0 and not bfile.startswith("."):
                bibfull.append(bfile.strip())
    return bibfull


def main(args):
    """Performs main processing."""
    # Parse command line arguments.
    kwargs = parseargs(args)
    output = kwargs["output"]
    
    # Get and write dependencies. If an exception occurs, write a traceback to
    # the dep file as a comment.
    out = open(output, "w") if output is not None else sys.stdout
    with out:
        try:
            sourcefile = SourceFile(kwargs["file"], builddir=kwargs["build"])
            sourcefile.getdeps()
            sourcefile.writedeps(out)
        except Exception:
            if out is not sys.stdout:
                with io.StringIO() as err:
                    traceback.print_exc(file=err)
                    err.seek(0)
                    for line in err:
                        out.write("# " + line)
            raise


# Call main.
if __name__ == "__main__":
    main(sys.argv[1:])
