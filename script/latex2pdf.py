#!/usr/bin/env python3

# Help message is automatically generated by argparse module. Invoke from a
# terminal to see all available options.
"""
Adapted from the bash script latex2pdf, this script tries to automatically run
pdflatex, bibtex, and makeindex enough times to get everything resolved. It
is quite solid for simple documents (i.e., a single .tex file with no \include
statements), but for larger projects, it may run some things more than it
needs to.

This script will check all of the included bibliography files to see if the
corresponding bbl need to be updated. This means that if you change a bib file
and then run this script, the bibliography changes will actually show up in
your document.

If you're using a package that requires multiple pdflatex runs (and it does not
output any standard warning message to tell you when you need to run pdflatex
again), then consider using the --min-runs option. This can make sure pdflatex
runs at least 2 times (or more).

To determine whether to keep running pdflatex, the script will check whether
various "scratch files" (e.g., the .aux file, tables of contents, etc.) change
each time pdflatex is run. If any of these files are changed (determined by
comparng md5 sums before and after pdflatex is run), then pdflatex will be
run again (up to --max-runs times). Note that if, for whatever reason, you are
printing a timestamp in the aux file, then this will break because aux files
never stop changing. If you are in this situation, you can set the --ignore-md5
flag, which will skip comparing md5 sums on the final latex run; if there are
no other errors, this will allow for a clean finish.

By default, if this script finishes with an error, the modified timestamp of
the pdf output is set to 1 second before the tex input so that the resulitng
pdf is "out of date" with respect to the tex file. This is useful when using
make, as it ensures the pdf will be remade after a second call to make. This
behavior is disabled with the --keep-pdf-timestamp flag.

Author: Michael Risbeck <risbeck@wisc.edu>
"""

import argparse
import collections
import contextlib
import functools
import hashlib
import os
import re
import shlex
import shutil
import string
import subprocess
import sys
import tempfile
import traceback

# Helper function for parser.
def getfilecheck(ext=None, directory=False, exists=True, toAbs=False):
    """
    Returns a funcion to check whether inputs are valid files/directories.
    """
    def filecheck(s):
        s = str(s)
        if toAbs:
            try:
                s = os.path.abspath(s)
            except Exception as err: # Catch everything here.
                raise argparse.ArgumentTypeError("unable to get absolute "
                                                 "path") from err
        if ext is not None and not s.endswith(ext):
            raise argparse.ArgumentTypeError("must have '{}' "
                                             "extension".format(ext))
        if exists:
            if directory:
                if not os.path.isdir(s):
                    raise argparse.ArgumentTypeError("must be an existing "
                                                     "directory")
            elif not os.path.isfile(s):
                raise argparse.ArgumentTypeError("must be an existing file")
        return s
    return filecheck

# Build the parser in the global namespace so everybody has access.
parser = argparse.ArgumentParser(add_help=False, description=
        "runs pdflatex, bibtex, etc. on a .tex file to produce a pdf",
        epilog=__doc__, formatter_class=argparse.RawDescriptionHelpFormatter)

optargs = parser.add_argument_group("normal options")
optargs.add_argument("--help", help="print this help", action="help")
optargs.add_argument("--dir", help="working directory to run pdflatex, etc.",
                     type=getfilecheck(directory=True,toAbs=True),
                     default=os.getcwd())
optargs.add_argument("--texinputs", help="extra directories for tex inputs "
                     "(relative to DIR)", action="append", default=[])
optargs.add_argument("--bibinputs", action="append", default=[],
                     help="extra directories for bib inputs (relative to DIR)")
optargs.add_argument("--min-runs", help="minimum number of pdflatex runs",
                     type=int, default=1)
optargs.add_argument("--max-runs", help="maximum number of pdflatex runs",
                     type=int, default=4)
optargs.add_argument("--display", help="set display level (default: errors)",
                     choices=set(["all","some","errors","none"]),
                     default="errors")

advargs = parser.add_argument_group("advanced options")
advargs.add_argument("--pdflatex", help="shell command for pdflatex",
                     default="pdflatex")
advargs.add_argument("--flags", help="flags to pdflatex",
                     default="--synctex=1  --halt-on-error")
advargs.add_argument("--debug", help="print extra debugging information",
                     action="store_true")
advargs.add_argument("--ignore-cite-errors", action="store_true",
                     help="ignore citation errors on final run")
advargs.add_argument("--ignore-fatal-errors", action="store_true",
                     help="keep trying pdflatex even after a fatal error")
advargs.add_argument("--keep-pdf-timestamp", action="store_true",
                     help="Don't adjust pdf timestamp on error (see below)")
advargs.add_argument("--ignore-md5", action="store_true",
                     help="ignore md5 sums on final run (see below)")
advargs.add_argument("--trust-initial-files", action="store_true",
                     help="skip processing step on initial scratch files")

reqargs = parser.add_argument_group("required arguments")
reqargs.add_argument("texfile", help="source .tex file",
                     type=getfilecheck(ext=".tex", toAbs=True))

# Don't show help for these options as they are either esoteric or can lead to
# very bad things.
parser.add_argument("--DEFAULT-FLAGS", help=argparse.SUPPRESS,
                    default="--interaction=nonstopmode  --recorder")


# Some helper functions.
openlog = functools.partial(open, mode="r", encoding="ascii", errors="replace")


def errorout(message="Invalid Usage", doc=False, usage=True,
             crash=True, fromerr=None):
    """Prints help and exits by raising an exception."""
    if doc:
        parser.print_help()
    elif usage:
        parser.print_usage()
    if crash:
        raise RuntimeError(message) from fromerr


def changeext(file, ext):
    """Changes the extension of file to ext. ext should include the dot."""
    (filebase, _) = os.path.splitext(file)
    return filebase + ext


def kpsewhich(biblist, cwd="."):
    """
    Runs kpsewhich on a list of bib files and returns full paths for each.
    
    Can also take a single file name. Will return None if the file is not
    found.
    """
    single = isinstance(biblist, str)
    if single:
        biblist = [biblist]
    kpse = subprocess.Popen(["kpsewhich"] + biblist, cwd=cwd,
                            stdout=subprocess.PIPE)
    (bibfullraw, kpsewhicherr) = kpse.communicate()
    bibfull = getfullpaths(bibfullraw.decode().split("\n"), pdir=cwd)
    if single:
        try:
            [bibfull] = bibfull
        except ValueError:
            bibfull = None
    return bibfull


def getfullpaths(files, pdir=None, empty=False):
    """
    Gets full file names for each element of files."

    pdir is used as the prefix for relative paths. Set empty=True to still
    include empty strings in files. Otherwise, they are skipped.
    """
    minlen = 0 if empty else 1
    if pdir is None:
        pdir = os.getcwd()
    fullpaths = []
    for f in files:
        if len(f) >= minlen:
            fullpaths.append(os.path.normpath(os.path.join(pdir, f.strip())))
    return fullpaths


def getmd5sum(filename, block=128, na=None):
    """
    Returns md5 digest of a file.
    """
    try:
        with open(filename, "rb") as f:
            md5 = hashlib.md5()
            for chunk in iter(lambda: f.read(block*md5.block_size), b""):
                md5.update(chunk)
        md5 = md5.hexdigest()
    except FileNotFoundError:
        md5 = na
    return md5


def getmtime(f, na=-float("inf")):
    """
    Wrapper to os.path.getmtime, returning -inf if a file doesn't exist.

    The optional argument na controls what is returned for files that don't
    exist.
    """
    try:
        t = os.path.getmtime(f)
    except OSError:
        t = na
    return t


# Classes for dealing with intermediate files.
class ScratchFile:
    """Generic Latex scratch file."""
    def __init__(self, file, builddir=".", rundir=".", skip_md5=False):
        """Initialize the object."""
        self.builddir = os.path.abspath(builddir)
        self.abspath = os.path.join(self.builddir, file)
        self.relpath = os.path.relpath(self.abspath, self.builddir)
        self.displayname = os.path.relpath(self.abspath,
                                           os.path.abspath(rundir))
        self.ext = os.path.splitext(self.abspath)[1]
        self.skip_md5 = skip_md5
        self.md5 = self.getmd5()
        self.wasupdated = False
        self.updatereasons = []
        self.dependencies = []
    
    @property
    def exists(self):
        """Whether the file currently exists."""
        return os.path.isfile(self.abspath)
    
    def getmd5(self):
        """
        Get md5 sum for file.
        
        Returns None if file doesn't exist or if self.skip_md5 is True.
        """
        return None if self.skip_md5 else getmd5sum(self.abspath, na=None)
    
    def getmtime(self, na=0):
        """Gets mtime for file. Returns na if file doesn't exist."""
        return getmtime(self.abspath, na=na)
    
    def marknew(self):
        """Mark the file as new."""
        self.wasupdated = True
        self.updatereasons.append("File is new")
    
    def checkforupdates(self):
        """
        Checks whether the file is up to date.
        
        Sets (and returns) self.wasupdated. Note that the file's dependencies
        are also checked for updates, but only by looking at the wasupdated
        attribute.
        """
        currentmd5 = self.getmd5()
        md5changed = (not self.skip_md5) and currentmd5 != self.md5
        if md5changed:
            self.wasupdated = True
            self.updatereasons.append("file contents changed")
        self.md5 = currentmd5
        for dep in self.dependencies:
            if dep.wasupdated:
                self.wasupdated = True
                self.updatereasons.append("dependency <{}> changed"
                                          .format(dep.displayname))
        return self.wasupdated
        
    def process(self, *args, **kwargs):
        """
        Run processing if file was updated.
        
        Arguments passed to _do_processing().
        """
        if self.wasupdated:
            self._do_processing(*args, **kwargs)
        else:
            console.debug("File <{}> was not updated; skip processing",
                          self.displayname)  
        self.wasupdated = False
        self.updatereasons = []
    
    def _do_processing(self):
        """Perform actual processing step. Overridden in subclasses."""
        console.debug("No processing step for <{}>", self.displayname)
    
    def __eq__(self, other):
        """Checks for file equality."""
        if isinstance(other, str):
            path = other
        elif isinstance(other, ScratchFile):
            path = other.abspath
        else:
            return NotImplemented
        return self.abspath == path

    def __repr__(self):
        return "{}('{}')".format(self.__class__.__name__, self.displayname)


class AuxFile(ScratchFile):
    """Checks for bibliography data in an aux file."""
    def __init__(self, file, builddir=".", rundir=".", checkblx=False):
        """Initialize aux file with empty bibdata."""
        super().__init__(file, builddir=builddir, rundir=rundir)
        self.checkblx = checkblx
        self.bbl = ScratchFile(changeext(file, ".bbl"), builddir=builddir,
                               rundir=rundir)
        self.bibfiles = self.getbibfiles()
    
    def getbibfiles(self, abspath=True):
        """
        Searches filename for \bibdata{*} and returns bibliography files.
        """
        bibfiles = []
        bibdata = re.compile(r"\\bibdata\{(.*)\}")
        try:
            with openlog(self.abspath) as f:
                for line in f:
                    m = bibdata.match(line)
                    if m is not None:
                        for b in m.group(1).split(","):
                            b = b.strip() + ".bib"
                            if abspath:
                                babs = kpsewhich(b, self.builddir)
                                if babs is not None:
                                    b = babs
                                else:
                                    console.debug("kpsewhich did not find "
                                                  "bibliography file <{}>", b)
                            bibfiles.append(b)
        except FileNotFoundError:
            pass
        if not self.checkblx:
            bibfiles = [b for b in bibfiles if not b.endswith("-blx.bib")]
        return bibfiles
    
    def biboutofdate(self):
        """
        Check timestamps on bib files to see if bbl files need to be remade.
    
        Returns True if bbl file is out of date, which means bibtex needs to
        be run.
        """
        outofdate = False
        if len(self.bibfiles) > 0:
            bbltime = self.bbl.getmtime()
            outofdate = any(getmtime(b, na=float("inf")) >= bbltime
                            for b in self.bibfiles)
        return outofdate    
    
    def checkforupdates(self):
        """Checks whether bbl file is older than bib files."""
        wasupdated = super().checkforupdates()
        if wasupdated:
            self.bibfiles = self.getbibfiles()
        if self.biboutofdate():
            wasupdated = True
            self.updatereasons.append("bib files newer than bbl")
        self.wasupdated = wasupdated
        return wasupdated
    
    def _do_processing(self, stdout=None):
        """Runs bibtex on the aux file if bibliographies are present."""
        if len(self.bibfiles) == 0:
            console.debug("No processing step for <{}> (no bibliography)",
                          self.displayname)
            return
        console.status("running bibtex on <{}>", self.displayname)
        if self.relpath.startswith(".."):
            console.critical("Warning: file <{}> is not within "
                             "directory <{}>. Bibtex will likely "
                             "error.", self.relpath, self.builddir)
        bibtex = subprocess.Popen(["bibtex", self.relpath], cwd=self.builddir,
                                  stdout=stdout)
        bibtex.wait()
        if bibtex.returncode != 0:
            console.error("bibtex error [Code {:d}].", bibtex.returncode)
            blgfile = os.path.splitext(self.relpath)[0] + ".blg"
            absblgfile = os.path.join(self.builddir, blgfile)
            try:
                blgmessages = blgchecker.search(absblgfile)
            except IOError as err:
                errorout(message="Fatal bibtex error searching "
                         "file {} ".format(blgfile), usage=False,
                         fromerr=err)
            console.multiprint(blgmessages)


class IndexFile(ScratchFile):
    """Class for index files."""
    IN_EXT = ".idx"
    OUT_EXT = ".ind"
    
    def _do_processing(self, stdout=None):
        """Runs makeindex on the file."""
        console.status("Running makeindex on <{}>", self.displayname)
        if self.relpath.startswith(".."):
            console.critical("Warning: file <{}> is not within "
                             "directory <{}>. Makeindex will likely "
                             "error.", self.relpath, self.builddir)
        args = ["makeindex", "-o", self.relout, self.relpath]
        makeindex = subprocess.Popen(args, cwd=self.builddir,
                                     stdout=stdout, # Makeindex uses
                                     stderr=stdout) # stderr
        makeindex.wait()
    
    @property
    def relout(self):
        """Returns relative path for output file."""
        return changeext(self.relpath, self.OUT_EXT)
    
    def checkforupdates(self):
        """Checks whether the output file exists."""
        wasupdated = super().checkforupdates()
        out = changeext(self.abspath, self.OUT_EXT)
        if not os.path.isfile(out):
            wasupdated = True
            self.updatereasons.append("output <{}> does not exist"
                                      .format(changeext(self.displayname,
                                                        self.OUT_EXT)))
        self.wasupdated = wasupdated
        return wasupdated
    

class AuthorIndexFile(IndexFile):
    """Class for author index."""
    IN_EXT = ".ain"
    OUT_EXT = ".and"
    
    def _do_processing(self, stdout=None):
        """Runs authorindex and then makeindex."""
        console.status("Running authorindex on <{}>", self.displayname)
        auxfiles = [dep.relpath for dep in self.dependencies]
        args = ["authorindex", "-i", "-r",
                changeext(self.relpath, "")] + auxfiles
        authorindex = subprocess.Popen(args, cwd=self.builddir,
                                      stdout=stdout, stderr=stdout)
        authorindex.wait()
        super()._do_processing(stdout=stdout)
    
    
class CitationIndexFile(IndexFile):
    """Class for citation index."""
    IN_EXT = ".ctx"
    OUT_EXT = ".cnd"
    
    def _do_processing(self, stdout=None, backup=True):
        """Cleans the citation index and then runs makeindex."""
        console.status("Cleaning citation index <{}>", self.displayname)
        cleaner = CitationIndexCleaner()
        cleaner.clean(self.abspath)
        if backup:
            bak = self.abspath + ".clean"
            console.debug("Saving <{}> as <{}>", self.displayname,
                          os.path.relpath(bak))
            shutil.copyfile(self.abspath, bak)
        super()._do_processing(stdout=stdout)


# Helper classes for latex document.
class ScratchfileDict(collections.OrderedDict):
    """Utility dict for scratch files."""
    def add(self, scratchfile):
        """Adds a scratchfile, using the absolute path as a key."""
        self[scratchfile.abspath] = scratchfile
    
    def by_ext(self, ext=None):
        """
        Returns scratchfile by file extension.
        
        If ext is None, returns a dict of lists (with extensions as keys).
        Otherwise, returns a list of scratchfiles with that extension.
        """
        files = collections.defaultdict(list)
        for scratchfile in self.values():
            (_, fext) = os.path.splitext(scratchfile.abspath)
            files[fext].append(scratchfile)
        if ext is not None:
            files = files[ext]
        return files
    
    def sort(self):
        """
        Performs a topological sort on the object.
        
        The resulting order will be such that a file comes after all of its
        dependencies. If dependencies are circular, an error will be issued.
        """
        sortedorder = self.__class__()
        while len(self) > 0:
            added = []
            for (k, v) in self.items():
                if all(dep.abspath not in self for dep in v.dependencies):
                    added.append(k)
            if len(added) == 0:
                raise ValueError("Dependencies are circular! Unable to sort.")
            for k in added:
                sortedorder[k] = self.pop(k)
        self.update(**sortedorder)

    def __iter__(self):
        """Iterates over values by default."""
        return iter(self.values())


class RunStatus:
    """
    Class for status of a pdflatex run.
    
    Each field says whether an error (or something else that would require
    another run) occurred.
    """
    __slots__ = ["pdflatex", "log", "scratchfiles", "minruns", "fatal"]
    
    def __init__(self):
        """Initialize the object."""
        self.pdflatex = False
        self.log = False
        self.scratchfiles = False
        self.minruns = False
        self.fatal = False
    
    @property
    def successful(self):
        """Returns whether everything was successful."""
        return not any(getattr(self, f) for f in self.__slots__)


class LatexDocument:
    """Class for compiling a latex document."""
    scratchfile_classes = {
        ".ain": AuthorIndexFile, # Author index.
        ".aux": AuxFile, # Main auxiliary file.
        ".ctx": CitationIndexFile, # Citation index.
        ".idx": IndexFile, # Subject index.
        ".lof": ScratchFile, # List of figures.
        ".loe": ScratchFile, # List of examples.
        ".lot": ScratchFile, # List of tables.
        ".out": ScratchFile, # Beamer outline.
        ".nav": ScratchFile, # Beamer navigation file.
        ".toc": ScratchFile, # Table of contents.
    }
    scratchfile_dependencies = {
        ".ain": ".aux", # Author index depends on bibliography.
        ".ctx": ".aux", # Citation index depends on bibliography.        
    }
    
    def __init__(self, file, pdflatex, builddir=".", rundir=".", stdout=None):
        """Initialize the object."""
        self.builddir = os.path.abspath(builddir)
        self.abspath = os.path.join(self.builddir, file)
        self.relpath = os.path.relpath(self.abspath, self.builddir)
        self.rundir = os.path.abspath(rundir)
        self.displayname = os.path.relpath(self.abspath, self.rundir)
        self.pdflatex = pdflatex
        self.stdout = stdout
        self.save_cleaned_ctx = True
        self.scratchfiles = ScratchfileDict()
        self.runcount = 1
        self.minruns = 1
        self.maxruns = 4
        self.ignore_final_cite_errors = False
        self.ignore_fatal_errors = False
        self.keep_pdf_timestamp = False
        self.ignore_final_md5 = False
        self.trust_initial_files = False
    
    def extrafile(self, ext, relative=False):
        """Gives path to extra file in build directory."""
        base = os.path.basename(self.abspath)
        if not relative:
            base = os.path.join(self.builddir, base)
        return changeext(base, ext)
    
    def compile(self):
        """Compile the latex document."""
        # Populate initial scratch files.
        self.update_scratch_files(initial=True)
        
        # Run main loop.
        while True:
            status = self.compile_once()
            if (status.successful or status.fatal
                    or self.runcount == self.maxruns):
                break
            self.runcount += 1
            
        # Check exit status.
        if status.successful:
            console.debugstatus("Successful completion.")
        else:
            # Choose error message.
            if status.fatal:
                message = "Fatal error in run {:d}".format(self.runcount)
            elif status.scratchfiles:
                changed = []
                for f in self.scratchfiles:
                    if f.wasupdated:
                        changed.append(f.displayname)
                message = ("Scratch files not constant after {:d} runs: {}"
                           .format(self.runcount, ", ".join(changed)))
            else:
                message = ("Errors persist after {:d} runs"
                           .format(self.runcount))
            
            # Set pdf timestamp so pdf is older than tex file.
            if not self.keep_pdf_timestamp:
                tex = self.abspath
                pdf = self.extrafile(".pdf")
                if all(os.path.isfile(f) for f in [tex, pdf]):
                    mtime = os.path.getmtime(tex) - 1
                    os.utime(pdf, (mtime, mtime))
            
            # Quit with error message.
            errorout(message, doc=False, usage=False)
    
    def compile_once(self):
        """Runs one compilation step and return whether to keep going."""
        status = RunStatus()
        
        # Run bibtex, makeindex, etc.
        if self.runcount > 1 or not self.trust_initial_files:
            self.process_scratch_files()
        
        # Run pdflatex.
        console.status("running pdflatex on <{}> ({:d})", self.displayname,
                       self.runcount)
        pdflatex = subprocess.Popen(self.pdflatex + [self.relpath],
                                    cwd=self.builddir, stdout=self.stdout)
        pdflatex.wait()
        if pdflatex.returncode != 0:
            status.pdflatex = True
            console.error("pdflatex error [Code {:d}]. Check log.",
                          pdflatex.returncode)
        
        # Check log file for any errors or warnings. If final run, display
        # undefined citations as errors.
        if self.runcount == self.maxruns:
            citeerror = "ignore" if self.ignore_final_cite_errors else "error"
            for k in ["undef", "undefref", "undefcite"]:
                logchecker.change(k, level=citeerror)
        logmessages = logchecker.search(self.extrafile(".log"))
        console.multiprint(logmessages)
        if any(len(logmessages[k]) > 0 for k in ["warning", "error", "fatal"]):
            status.log = True
        if len(logmessages["fatal"]) > 0:
            if self.ignore_fatal_errors:
                console.debug("Fatal errors found!")
            else:
                status.fatal = True
        
        # Check whether scratch files changed.
        if self.ignore_final_md5 and self.runcount == self.maxruns:
            for sf in self.scratchfiles:
                sf.skip_md5 = True
        status.scratchfiles = self.update_scratch_files()
        
        # Check whether minimum runs met.
        if self.runcount < self.minruns:
            status.minruns = True
            console.debug("Have not met minimum runs ({:d} of {:d})",
                          self.runcount, self.minruns)
        
        # Return status.
        return status
    
    def update_scratch_files(self, initial=False):
        """
        Updates the scratchfiles dictionary.
        
        Returns whether or not files were updated or new.
        """
        wasupdated = False
        thisscratchfiles = ScratchfileDict()
        
        # Get a list of all ScratchFile objects.
        outputfiles = self.getoutputfiles(mustexist=not initial)
        kwargs = dict(builddir=self.builddir, rundir=self.rundir)
        for file in outputfiles:
            (_, ext) = os.path.splitext(file)
            if ext in self.scratchfile_classes:
                if initial or file not in self.scratchfiles:
                    sf = self.scratchfile_classes[ext](file, **kwargs)
                    if initial:
                        with console.bulleted():
                            if sf.exists:
                                console.debug("Found existing file <{}>.",
                                              sf.displayname)
                            else:
                                console.debug("File <{}> is mentioned but does"
                                              " not exist.", sf.displayname)
                    else:
                        sf.marknew()
                else:
                    sf = self.scratchfiles[file]
                thisscratchfiles.add(sf)
        
        # Add dependencies and sort.
        for sf in thisscratchfiles:
            depext = self.scratchfile_dependencies.get(sf.ext, None)
            if depext is not None:
                sf.dependencies = thisscratchfiles.by_ext(depext)
        thisscratchfiles.sort()
        
        # Check for updates.
        wasupdated = False
        for sf in thisscratchfiles:
            if initial:
                if not self.trust_initial_files:
                    sf.wasupdated = True
            else:
                sf.checkforupdates()
                with console.bulleted():
                    if sf.wasupdated:
                        console.debug("File <{}> needs another run: {}",
                                      sf.displayname,
                                      "; ".join(sf.updatereasons))
                    else:
                        console.debug("File <{}> is unchanged.",
                                      sf.displayname)
            wasupdated |= sf.wasupdated
        
        # Save scratchfiles and return.
        self.scratchfiles = thisscratchfiles
        return wasupdated

    def getoutputfiles(self, mustexist=True):
        """Gets a list of outputs from the .fls file."""
        flspath = self.extrafile(".fls")
        flsrelpath = changeext(self.displayname, ".fls")
        prefix = "OUTPUT "
        outputs = []
        try:
            with open(flspath, "r") as fls:
                console.debug("Reading file <{}>.", flsrelpath)
                for line in fls:
                    if line.startswith(prefix):
                        file = line[len(prefix):].strip()
                        absfile = os.path.join(self.builddir, file)
                        if absfile not in outputs:
                            outputs.append(absfile)
        except FileNotFoundError as err:
            if mustexist:
                raise FileNotFoundError("File <{}> not found; should have "
                                        "been produced by pdflatex!"
                                        .format(flsrelpath))
            else:
                console.debug("File <{}> does not exist. All scratch files "
                              "will be treated as new.", flsrelpath)
                outputs = []
        return outputs
    
    def process_scratch_files(self):
        """Runs processing step on all scratch files."""
        console.debug("Processing scratch files.")
        for scratchfile in self.scratchfiles:
            kwargs = self._get_process_args(scratchfile)
            scratchfile.process(**kwargs)

    def _get_process_args(self, scratchfile):
        """Gets arguments to give to the .process() method of scratchfile."""
        kwargs = dict(stdout=self.stdout)
        if isinstance(scratchfile, AuthorIndexFile):
            pass
        elif isinstance(scratchfile, CitationIndexFile):
            kwargs.update(backup=self.save_cleaned_ctx)
        elif isinstance(scratchfile, IndexFile):
            pass
        elif isinstance(scratchfile, AuxFile):
            pass
        elif isinstance(scratchfile, ScratchFile):
            kwargs.pop("stdout")
        else:
            raise TypeError("Unknown type for scratchfile: {}"
                            .format(type(scratchfile)))
        return kwargs


# Class for processing the log file.
class ErrorChecker:
    """Uses regexes to search for error messages in log files."""
    def __init__(self, defaultlevel="error"):
        """Initialize the object."""
        self.__checks = collections.OrderedDict()
        self.__Check = collections.namedtuple("Check", ["regex", "level",
                                                        "lines"])
        self.defaultlevel = defaultlevel

    def add(self, regex=None, *, level=None, lines=1, name=None):
        """
        Adds a new or modifies an existing regex to look for.

        The pattern string for the regex must be provided. Optionally, it can
        be given a string name that allows you to modify it later. Other
        options error decides whether the message indicates an error that
        should be printed, and if so, lines says how many lines from the log
        file should be printed.

        Returns the name given to the regex.
        """
        # Get name.
        if name is None:
            name = len(self.__checks)
        elif not isinstance(name, str):
            raise TypeError("name must be a str, not {}".format(type(name)))
        elif name in self.__checks:
            raise ValueError("name '{}' is already used".format(name))

        # Get default level.
        if level is None:
            level = self.defaultlevel

        # Add the new tuple and return name.
        self.__checks[name] = self.__Check(re.compile(regex), level, lines)
        return name

    def change(self, name, *, level=None, lines=None):
        """
        Modifies the options for a given regex.

        name should be the identifier given when originally added.
        """
        if name not in self.__checks:
            raise KeyError("Name '{}' is not known!".format(name))
        default = self.__checks[name]
        if level is None:
            level = default.level
        if lines is None:
            lines = default.lines
        self.__checks[name] = self.__Check(default.regex, level, lines)

    def search(self, logfile):
        """
        Searches logfile for the messages and returns errors and warnings.

        Return value is a dict whose keys are the levels of each error and
        whose values are lists of the error messages.
        """
        messages = collections.defaultdict(list)
        with openlog(logfile) as log:
            for line in log:
                for check in self.__checks.values():
                    m = check.regex.search(line)
                    if m is not None:
                        # Match found. Get any extra lines.
                        match = [line.strip("\n")]
                        for n in range(check.lines - 1):
                            match.append(next(log, "").strip("\n"))
                        match = "\n".join(match)
                        messages[check.level].append(match)
                        break
        return messages

# Regexes to search log file. Give a name to items that we may want to
# change to an error later. Note that order matters in the sense that as soon
# as a line matches one message, the rest are skipped. Thus, you should put
# The most specific messages first.
logchecker = ErrorChecker(defaultlevel="warning")
logchecker.add("Warning:.*Rerun to get cross")
logchecker.add("Warning:.*Citation.*may have changed")
logchecker.add("Warning:.*Citation.*undefined", name="undefcite")
logchecker.add(r"Warning: Reference `.*' on page \d+ undefined",
               name="undefref")
logchecker.add("Warning:.*There were undefined (references|citations)",
               name="undef")
logchecker.add(r"No file .*\.(bbl|toc|[aic]nd)")
logchecker.add("Package rerunfilecheck Warning: File.*has changed")
logchecker.add("! Undefined control sequence", lines=2, level="fatal")
logchecker.add("!  ==> Fatal error occurred", level="fatal")
logchecker.add("! Missing.*inserted", lines=5, level="fatal")
logchecker.add("! Argument of .* has an extra", lines=4, level="fatal")
logchecker.add("! Display math should end with", level="fatal", lines=4)
logchecker.add("! Too many", level="fatal", lines=3)
logchecker.add("! Misplaced alignment tab character &.", lines=3,
               level="fatal")
logchecker.add("! LaTeX Error: Bad math environment delimiter.", lines=8,
               level="fatal")
logchecker.add("LaTeX Error:", level="fatal")
logchecker.add("! Package.*Error", level="fatal")

# Regexes to search bib file.
blgchecker = ErrorChecker(defaultlevel="error")
blgchecker.add(r"Repeated entry---line \d* of file", lines=4)
blgchecker.add("Warning--I didn't find a database entry for")
blgchecker.add(r"I was expecting a .* or a .*---line \d* of file", lines=5)
blgchecker.add("Warning--entry type for .* isn't style-file defined", lines=2)
blgchecker.add("I couldn't open database file", lines=4)


# Class for displaying status information.
class StatusConsole:
    """Lightweight logging class to print progress."""
    def __init__(self, status=True, errors=True, debug=False, critical=True):
        """Initializes and sets logging level."""
        self.show_status = status
        self.show_errors = errors
        self.show_debug = debug
        self.show_critical = critical

        # Set printing formats.
        self.formats = collections.defaultdict(lambda : "{}")
        self.formats["debug"] = " |  {}"
        self.formats["error"] = " !! {}"
        self.formats["status"] = "*** {}"
        self.formats["critical"] = ">>> {}"
        
        # Initialize empty list of transformations.
        self.__transformations = []

    def multiprint(self, messages):
        """Prints messages from the output of ErrorChecker.search()."""
        self.multiignore(messages["ignore"])
        self.multidebug(messages["warning"])
        if self.show_debug or len(messages["fatal"]) == 0:
            self.multierror(messages["error"])
        self.multierror(messages["fatal"], "fatal errors")

    def status(self, message, *args, **kwargs):
        """Prints a status message."""
        if self.show_status or self.show_debug:
            message = message.format(*args, **kwargs)
            self._printlines(message.split("\n"), fmt="status")

    def debug(self, message, *args, **kwargs):
        """Prints a debug message."""
        if self.show_debug:
            message = message.format(*args, **kwargs)
            self._printlines(message.split("\n"), fmt="debug")

    def debugstatus(self, message, *args, **kwargs):
        """Prints a status message that only shows in debug mode."""
        if self.show_debug:
            message = message.format(*args, **kwargs)
            self._printlines(message.split("\n"), fmt="status")

    def error(self, message, *args, **kwargs):
        """Prints an error message."""
        if self.show_errors or self.show_debug:
            message = message.format(*args, **kwargs)
            self._printlines(message.split("\n"), fmt="error")

    def multierror(self, errors, etype="errors"):
        """Prints a bulleted list of multiple errors."""
        if (self.show_errors or self.show_debug) and len(errors) > 0:
            self.error("Found the following {}:", etype)
            with self.bulleted():
                self._printlines(errors, fmt="error")

    def multidebug(self, debugs):
        """Prints a bulleted list of multiple debug statements."""
        if self.show_debug and len(debugs) > 0:
            self.debug("Found the following warnings:")
            with self.bulleted():
                self._printlines(debugs, fmt="debug")

    def multiignore(self, ignores):
        """Prints a bulleted list of ignored messages."""
        if self.show_debug and len(ignores) > 0:
            self.debug("Ignoring the following messages:")
            with self.bulleted():
                self._print(ignores, fmt="debug")

    def critical(self, message, *args, **kwargs):
        """Prints a critical message."""
        if self.show_critical or self.show_debug:
            message = message.format(*args, **kwargs)
            self._printlines(message.split("\n"), fmt="critical")

    @contextlib.contextmanager
    def bulleted(self, bullet=None):
        """Context manager to print lines as a bulleted list."""
        kwargs = {}
        if bullet is not None:
            kwargs["bullet"] = bullet
        transformation = functools.partial(self._bullet_transformation,
                                           **kwargs)
        self.__transformations.append(transformation)
        yield
        self.__transformations.pop()

    def _transform_strings(self, strings, transformations=None):
        """Transformation iterator. strings should be an iterable of str."""
        if transformations is None:
            transformations = self.__transformations
        for s in strings:
            for t in reversed(transformations):
                s = t(s)
            yield s

    def _bullet_transformation(self, s, bullet="  > "):
        """Adds a bullet (and appropriate indentation) to string."""
        s = (bullet + s).replace("\n", "\n" + " "*len(bullet))
        return s

    def _printlines(self, strings, fmt=None):
        """Prints multiple strings, formatting each line using fmt."""
        fmt = self.formats[fmt]
        for s in self._transform_strings(strings):
            for line in s.split("\n"):
                print(fmt.format(line))
console = StatusConsole() # Global instance for printing.


# Class to properly format the citation index.
class CitationIndexCleaner:
    """Functions to help make a clean citation index."""
    def __init__(self):
        """Compiles all necessary regexes."""
        self.entryre = re.compile(r"\\indexentry \{\{(?P<author>.*?)\}\\ "
                                   "(?P<year>.*?)\}\{(?P<page>.*?)\}")
        self.tokenre = re.compile(r"\\[^ \{] ?")

        self.spaceafterre = re.compile(r"\{\s+")
        self.spacebeforere = re.compile(r"\s+\}")

        self.keeptext = set(string.ascii_letters + string.digits + " ")

        self.replacements = [
            (r"\OE", "OE"),
            (r"\aa", "a"),
            (r"\O", "O"),
            (r"\o", "o"),
            (r"\ss", "s"),
            (r"\ae", "ae"),
            (r"\AA", "A"),
            (r"\L", "L"),
            (r"\l", "l"),
            (r"\oe", "oe"),
            (r"\ae", "AE"),
            ("~", " ")
        ]

    def nobracespace(self, s):
        """
        Gets rid of whitespace immediately inside braces.
        """
        s = self.spacebeforere.sub("{", s)
        s = self.spaceafterre.sub("}", s)
        return s

    def keep(self, s):
        """Returns true or false whether s is in KEEPTEXT."""
        return (s in self.keeptext)

    def purify(self, name):
        """
        Returns "purified" version of name.
        """
        name = self.nobracespace(name)
        for (find, repl) in self.replacements:
            name = name.replace(find, repl)
        name = self.tokenre.sub("", name)
        name = "".join(filter(self.keep, name))
        return name.upper()

    def clean(self, infilename, outfilename=None):
        """
        Makes a clean citationindex from infile.
        """
        # Choose output file.
        if outfilename is None:
            indir = os.path.split(infilename)[0]
            kwargs = dict(dir=indir, prefix="authorindex_", delete=False)
            getoutfile = lambda : tempfile.NamedTemporaryFile("w", **kwargs)
        else:
            getoutfile = lambda : open(outfilename, "w")

        # Do main loop.
        with open(infilename, "r") as infile, getoutfile() as outfile:
            console.debug("opened file '{}' for citationindex.",
                          os.path.relpath(outfile.name))
            for (i, line) in enumerate(infile):
                match = self.entryre.search(line)
                if match is not None:
                    name = match.group("author")
                    nicename = self.purify(name)
                    year = match.group("year")
                    niceyear = self.purify(year)
                    page = match.group("page")

                    key = r"{%s}\ %s" % (name, year)
                    nicekey = " ".join([nicename, niceyear])

                    entry = r"\indexentry{%s@%s}{%s}" % (nicekey, key, page)
                    outfile.write(entry + "\n")
                else:
                    raise RuntimeError("No citation index entry on line "
                                       "{:d} of '{}'. Is the citation index "
                                       "corrupt?".format(i, infilename))
            if outfilename is None:
                outfiletmp = outfile.name
            else:
                outfiletmp = None

        # Overwrite input file if no output file name was given.
        if outfiletmp is not None:
            console.debug("renaming '{}' to '{}'", os.path.relpath(outfiletmp),
                          os.path.relpath(infilename))
            os.rename(outfiletmp, infilename)


# Main function.
def main(*args):
    """
    Gets command line arguments as a list and runs the main script.

    Note that the name of the script is not needed as an argument; thus, to
    use arguments passed from the command line, this should be called as
    main(*sys.argv[1:]).
    """
    # Process arguments.
    options = vars(parser.parse_args(args))

    # Break out some arguments.
    displayoptions = {
        #     (some display, error display, stdout)
        "none" : (False, False, os.devnull),
        "some" : (True, False, os.devnull),
        "errors" : (True, True, os.devnull),
        "all" : (True, True, None),
    }
    (somedisplay, errordisplay, stdout) = displayoptions[options["display"]]
    if stdout is not None:
        stdout = open(stdout, "w")

    # Set console options for printing.
    debug = options["debug"]
    console.show_status = somedisplay
    console.show_errors = errordisplay
    console.show_debug = debug
    logchecker.change("undefcite", level="warning")
    if debug:
        console.status("Running latex2pdf.py")
        console.debug("Given arguments {}", " ".join(args))

    # Set environment variables.
    os.environ["max_print_line"] ="2048" # Avoids line breaks in log file.
    for k in ["texinputs", "bibinputs"]:
        if len(options[k]) > 0:
            K = k.upper()
            os.environ[K] = ":".join([os.environ.get(K, "")] + options[k])
            console.debug("Set environment variable {} to '{}'", K,
                          os.environ[K])
    
    # Create latex document object and set options.
    pdflatex = ([options["pdflatex"]]
                + shlex.split(options["flags"] + " "
                              + options["DEFAULT_FLAGS"]))
    document = LatexDocument(options["texfile"], pdflatex=pdflatex,
                             builddir=options["dir"], stdout=stdout)
    document.minruns = options["min_runs"]
    document.maxruns = options["max_runs"]
    document.ignore_final_cite_errors = options["ignore_cite_errors"]
    document.ignore_fatal_errors = options["ignore_fatal_errors"]
    document.keep_pdf_timestamps = options["keep_pdf_timestamp"]
    document.ignore_final_md5 = options["ignore_md5"]
    document.trust_initial_files = options["trust_initial_files"]
    
    # Run compilation.
    document.compile()


# Finally, run main file.
if __name__ == "__main__":
    try:
        main(*sys.argv[1:])
        sys.exit(0)
    except Exception as err:
        if console.show_debug:
            traceback.print_exc()
        console.critical(str(err))
        sys.exit(1)
